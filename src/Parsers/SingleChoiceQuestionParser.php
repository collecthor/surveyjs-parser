<?php

declare(strict_types=1);

namespace Collecthor\SurveyjsParser\Parsers;

use Collecthor\DataInterfaces\ClosedVariableInterface;
use Collecthor\DataInterfaces\VariableInterface;
use Collecthor\SurveyjsParser\ElementParserInterface;
use Collecthor\SurveyjsParser\ParserHelpers;
use Collecthor\SurveyjsParser\ResolvableVariableSet;
use Collecthor\SurveyjsParser\SurveyConfiguration;
use Collecthor\SurveyjsParser\Values\IntegerValueOption;
use Collecthor\SurveyjsParser\Values\StringValueOption;
use Collecthor\SurveyjsParser\Variables\DeferredVariable;
use Collecthor\SurveyjsParser\Variables\OpenTextVariable;
use Collecthor\SurveyjsParser\Variables\SingleChoiceVariable;
use Exception;
use ValueError;

class SingleChoiceQuestionParser implements ElementParserInterface
{
    use ParserHelpers;

    public function parse(
        ElementParserInterface $root,
        array $questionConfig,
        SurveyConfiguration $surveyConfiguration,
        array $dataPrefix = []
    ): iterable {
        $dataPath = [...$dataPrefix, $this->extractValueName($questionConfig)];
        $id = implode('.', $dataPath);
        $titles = $this->extractTitles($questionConfig);

        // Parse the answer options.
        $choices = $this->extractChoices($this->extractOptionalArray($questionConfig, 'choices'));

        // Add autogenerated options
        $max = $this->extractOptionalInteger($questionConfig, 'choicesMax');
        if (isset($max)) {
            $min = $this->extractOptionalInteger($questionConfig, 'choicesMin') ?? 0;
            $step = $this->extractOptionalInteger($questionConfig, 'choicesStep') ?? 1;
            for ($i = $min;  $i < $max; $i += $step) {
                $choices[] = new IntegerValueOption($i, ['default' => (string) $i]);
            }
        }

        // Check if we need to add options for `hasNone` or `hasOther`
        if ($this->extractOptionalBoolean($questionConfig, 'hasNone') ?? false) {
            $choices[] = new StringValueOption('none', $this->extractLocalizedTexts($questionConfig, 'noneText'));
        }

        if ($this->extractOptionalBoolean($questionConfig, 'hasOther') ?? false) {
            if (!$surveyConfiguration->storeOthersAsComment) {
                yield new OpenTextVariable($id, $titles, $dataPath, $questionConfig);
                return;
            }
            $choices[] = new StringValueOption('other', $this->extractLocalizedTexts($questionConfig, 'otherText'));
        }

        // choicesFromQuestion
        if (isset($questionConfig['choicesFromQuestion']) && is_string($questionConfig['choicesFromQuestion'])) {
            if (!$surveyConfiguration->storeOthersAsComment) {
                throw new Exception('The combination of choicesFromQuestion and storeOthersAsComment is not supported yet');
            }
            yield new DeferredVariable(
                $id,
                static function (ResolvableVariableSet $set) use ($id, $titles, $dataPath, $questionConfig): VariableInterface {
                    $variable = $set->getVariable($questionConfig['choicesFromQuestion']);
                    if ($variable instanceof ClosedVariableInterface) {
                        $options = $variable->getValueOptions();
                        return new SingleChoiceVariable($id, $titles, $options, $dataPath, $questionConfig);
                    } else {
                        throw new ValueError("Question {$questionConfig['choicesFromQuestion']} does not implement ClosedQuestionInterface");
                    }
                },
            );
        } else {
            if ($choices === []) {
                throw new \InvalidArgumentException("Choices must not be empty");
            }
            yield new SingleChoiceVariable($id, $titles, $choices, $dataPath, $questionConfig);
        }
        yield from $this->parseCommentField($questionConfig, $surveyConfiguration, $dataPrefix);
    }
}
