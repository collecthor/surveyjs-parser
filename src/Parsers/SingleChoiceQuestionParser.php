<?php

declare(strict_types=1);

namespace Collecthor\SurveyjsParser\Parsers;

use Collecthor\SurveyjsParser\ElementParserInterface;
use Collecthor\SurveyjsParser\Interfaces\ClosedVariableInterface;
use Collecthor\SurveyjsParser\Interfaces\SpecialValueInterface;
use Collecthor\SurveyjsParser\Interfaces\ValueOptionInterface;
use Collecthor\SurveyjsParser\Interfaces\VariableInterface;
use Collecthor\SurveyjsParser\ParserHelpers;
use Collecthor\SurveyjsParser\ResolvableVariableSet;
use Collecthor\SurveyjsParser\SurveyConfiguration;
use Collecthor\SurveyjsParser\Values\IntegerValueOption;
use Collecthor\SurveyjsParser\Variables\DeferredVariable;
use Collecthor\SurveyjsParser\Variables\SingleChoiceVariable;
use ValueError;

class SingleChoiceQuestionParser implements ElementParserInterface
{
    use ParserHelpers;

    public function parse(
        ElementParserInterface $root,
        array $questionConfig,
        SurveyConfiguration $surveyConfiguration,
        array $dataPrefix = []
    ): iterable {
        $dataPath = [...$dataPrefix, $this->extractValueName($questionConfig)];
        $id = implode('.', $dataPath);
        $name = implode('.', [...$dataPrefix, $this->extractName($questionConfig)]);
        $titles = $this->extractTitles($questionConfig);

        // choicesFromQuestion
        if (isset($questionConfig['choicesFromQuestion']) && is_string($questionConfig['choicesFromQuestion'])) {
            yield new DeferredVariable(
                $name,
                static function (ResolvableVariableSet $set) use ($name, $titles, $dataPath, $questionConfig): VariableInterface {
                    $variable = $set->getVariable($questionConfig['choicesFromQuestion']);
                    if ($variable instanceof ClosedVariableInterface) {
                        return new SingleChoiceVariable(
                            name: $name,
                            options: array_filter($variable->getOptions(), function (ValueOptionInterface $option) {
                                return !$option instanceof SpecialValueInterface;
                            }),
                            dataPath: $dataPath,
                            rawConfiguration: $questionConfig,
                            titles: $titles
                        );
                    } else {
                        throw new ValueError("Question {$questionConfig['choicesFromQuestion']} does not have choices");
                    }
                },
            );
        } else {
            // Parse the answer options.
            $choices = $this->generateChoices($questionConfig);

            // Add autogenerated options
            $max = $this->extractOptionalInteger($questionConfig, 'choicesMax');
            if (isset($max)) {
                $min = $this->extractOptionalInteger($questionConfig, 'choicesMin') ?? 0;
                $step = $this->extractOptionalInteger($questionConfig, 'choicesStep') ?? 1;
                for ($i = $min;  $i < $max; $i += $step) {
                    $choices[] = new IntegerValueOption($i, ['default' => (string) $i]);
                }
            }
            yield new SingleChoiceVariable(
                $name,
                options: $choices,
                dataPath: $dataPath,
                rawConfiguration: $questionConfig,
                titles: $titles
            );
        }
        yield from $this->parseCommentField($questionConfig, $surveyConfiguration, $dataPrefix);
    }
}
